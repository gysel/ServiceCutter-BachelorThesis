\chapter{Implementation Details}
\label{appendix:implementationDetails}

This appendix contains detail documentation, code, or configuration files used to implement the Service Cutter.

\section{JSON Schema Export}
\label{appendix:exportSchema}

Listing \ref{code:exportSchema} lists the JSON Schema that specifies the export format for candidate service cuts.

\lstset{
	language=JavaScript,
	tabsize=3,
	%frame=lines,
	caption=JSON Schema for candidate services export.,
	label=code:exportSchema,
	frame=shadowbox,
	rulesepcolor=\color{gray},
	xleftmargin=20pt,
	framexleftmargin=15pt,
	keywordstyle=\color{blue}\bf,
	commentstyle=\color{OliveGreen},
	stringstyle=\color{red},
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
	showstringspaces=false,
	basicstyle=\footnotesize}
\lstinputlisting{code/JSONSchema_export.json}

\section{Docker Compose}
\label{appendix:dockerCompose}

A \gls{yaml} file is used to configure and start all Docker containers required for the Service Cutter. The file shown in Listing \ref{code:dockercompose} is delivered as \texttt{docker-compose.yml} in the source code of the Service Cutter.

In a productive environment the default passwords as defined in the Docker Compose file have to be changed.

\lstset{
   	language=,
   	tabsize=3,
   	%frame=lines,
   	caption=Docker Compose definition for the Service Cutter,
   	label=code:dockercompose,
   	frame=shadowbox,
   	rulesepcolor=\color{gray},
   	xleftmargin=20pt,
   	framexleftmargin=15pt,
   	keywordstyle=\color{blue}\bf,
   	commentstyle=\color{OliveGreen},
   	stringstyle=\color{red},
   	numbers=left,
   	numberstyle=\tiny,
   	numbersep=5pt,
   	breaklines=true,
   	showstringspaces=false,
   	basicstyle=\footnotesize}
\lstinputlisting{code/docker-compose.yml}


\subsection{Performance}
\label{app:performance}

This section theoretically discusses whether the Service Cutter scales to support large data volumes.

The theoretical number of edges may cause performance problems. The maximum number of edges in a graph can be described using a formula: A graph of $n$ nodes, where every node is connected to all other nodes, has $e$ edges.

\begin{displaymath}
e = \frac{n(n-1)}{2}
\end{displaymath}

The number of edges grows almost quadratically as shown in Table \ref{tab:edgesCount}.

\begin{table}[H]
	\centering
	\caption{Maximum number of edges in an undirected graph}
	\label{tab:edgesCount}
	\begin{tabular}{|r|r|}
		\hline \textbf{Nodes} $n$ & \textbf{Edges} $e$ \\ 
		\hline 2 & 1 \\ 
		\hline 3 & 3 \\ 
		\hline 20 & 190 \\ 
		\hline 50 & 1'225 \\ 
		\hline 100 & 4'950 \\ 
		\hline 2000 & 1'999'000 \\ 
		\hline 
	\end{tabular} 
\end{table}

Our implementation however will unlikely have anything close to the theoretical number of edges as:
\begin{itemize}
	\item Coupling of type \textit{Cohesiveness} only adds edges where nanoservices are in a relationship with each other.
	\item Coupling of type \textit{Compatibility} only adds a negative score (penalty) to existing relationships.
	\item Coupling of type \textit{Constraint} only removes existing edges.
\end{itemize}

The number of edges can therefore only cause problems when a Cohesiveness coupling is specified that includes a large number of nodes. An example of such a coupling is for a use case including a very large number of nanoentities which is a very unlikely case. We therefore conclude that the number of edges is probably not an issue.

\chapter{Working with the Service Cutter} 

This chapters presents possible approaches of working with the Service Cutter. Access to a test installation of the Service Cutter is preliminary to try the samples.

The Service Cutter's benefits, user representations, analysis of service cuts and two possible usage scenarios are covered in this chapter.

\section{Benefits}

The Service Cutter offers the following benefits:

\begin{itemize}
	\item By requesting different user representations, an architect is challenged to analyze which user representations and characteristics are relevant in his system. He might use the user representations as a check list for requirement engineering.
	\item The user representations and coupling criteria can further be used to educate junior architects or students on the driving forces of service decomposition.
	\item The Service Cutter provides candidate service cuts based on the defined user representations. With these candidate service cuts the architects expectations of the number of services and their definition is either verified or challenged. 
	\item The greenfield scenario as well as an iterative approach from moving from a monolith to service orientation are supported by the Service Cutter.
	\item Use cases are assigned to their responsible service. The published language between services is displayed in order to assist the development of services and their interfaces to each other.
	\item By storing the candidate service cuts, architectural decisions can be persisted and documented (not yet implemented).
\end{itemize}


%TODO Potential contents of this chapter:
%\begin{itemize}
%	\item How do you organize such an interview?
%	\item Documentation of input format?
%	\item When to choose which algorithm?
%	\item Recommendations for working with the priorities.
%\end{itemize}

\section{User Representations}
\label{sec:dataImport}

The Service Cutter provides a data import based on the user representations.

A user representation is a concept familiar to the architect that can be used to feed the criteria information into the Service Cutter. The following user representations are supported:

\begin{itemize}
\item An \textbf{\gls{ERM}} consists of data fields, entities and relationships. The data fields are imported as nanoentitites, the entities and relationships of type composition/inheritance as\textit{ Identity \& Lifecycle Commonality} and relationships of type aggegation as \textit{Semantic Proximity}.
\item \textbf{Use cases} primarly describe the \textit{Semantic Proximity} of a group of nanoentities. They can also be marked as latency critical which then results in \textit{Latency}.
\item \textbf{Shared owner group} represents a person, role or department that is responsible for a group of nanoentities, defining \textit{Shared Owner}.
\item An \textbf{aggregate} is a \gls{DDD} pattern defining a group of nanoentities that require consistency to each other which results in \textit{Consistency Constraint}. 
\item The \textbf{entity} is a \gls{DDD} pattern defining a common lifecycle and identify for a group of nanoentities. This defines \textit{Identity \& Lifecycle Commonality}.
\item A \textbf{predefined service} represents a service that already exists and therefore is harder or impossible to change. It defines the identically named criterion \textit{Predefined Service}.
\item \textbf{Separated security zones} represent groups of nanoentities that should not be combined into a common service for security reasons. They are defining the \textit{Security Constraints}.
\item A \textbf{security access group} represents a group of nanoentities that share a common security context, defining the \textit{Security Contextuality}.
\item \textbf{Compatibilities} can be used to import all coupling criteria of type \enquote{Compatability}.
\end{itemize}

Figure \ref{fig:userrep} lists all user representations and indicates which coupling criteria they are linked to.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.6]{diagrams/UserRep-CC.pdf}
		\caption{User representations and the related coupling criteria}
		\label{fig:userrep}
	\end{center}
\end{figure}

The technical format including \gls{JSON} schema files of all user representations is documented in Section \ref{subsec:restApis} or in more detail on GitHub\cite{githubWiki}. 

\section{Service Cut Analysis}

The Service Cutter offers an analysis mode. When activated, the relationships between services are visualized and the published language of the services is generated. Figure \ref{fig:service-dependency} outlines such a dependency: Nanoentities of Service A and D are read or written in a common use case. 

\begin{figure}[H]
	\centering{\includegraphics[scale=0.7]{images/screenshot-solver-analysis-example.png}}
	\caption{Service A and Service D share a use case.}
	\label{fig:service-dependency}
\end{figure}

The published language of Service D is visible in Figure \ref{fig:service-publang}.

\begin{figure}[H]
	\centering{\includegraphics[scale=0.7]{images/screenshot-solver-analysis-service.png}}
	\caption{Use cases and published language of Service D}
	\label{fig:service-publang}
\end{figure}

\section{Usage Scenarios}

\subsubsection{Monolith First}

The most likely scenario with existing software is the transition from a monolith to a service oriented architecture. Martin Fowler recommends to use this approach for every project and to not start a project with services\cite{fowlerMonolithFirst}. The Service Cutter is able to identify candidate service cuts with a given number of services. With the algorithm set to Girvan-Newman and the number of services to 2, the Service Cutter suggests a first service to be extracted from the monolith. by iteratively increasing the number of services one can see a possible path towards a service oriented architecture .

\subsubsection{Greenfield scenario}

The other scenario is the greenfield scenario when the system is not yet developed but partially specified and designed. The requested user representations can be used as checklist during requirements engineering and design processes. Specification artifacts are then loaded into the Service Cutter and candidate service cuts can be the basis for an inspiring discussion between architects. Once agreed on service cuts, the assigned use cases and published language helps to develop the services and their interfaces ot each other. 

\bigskip
The next chapter discusses the results of the thesis with the defined hypothesis's and requirements. 

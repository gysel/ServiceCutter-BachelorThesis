\chapter{Future Work}
\label{cha:futureWork}

This chapter explains possible enhancements of the Service Cutter as well as improvements to the concept of coupling criteria.

\section{Scoring}

The scoring system we developed for the Service Cutter works well for our test scenarios. However other systems might require further enhancements.

\subsection{Better Handling for Separations}

As discussed in Section \ref{subsec:singleDimensionality} we mapped coupling of type compatibility to negative scores and once all coupling criteria have been processed we remove all edges with a negative total score. This approach retains information about the coupling in a system. A refined concept in this area can be developed and evaluated leading to more accurate candidate service cuts.

\subsection{Implement Criteria of Type Communication}

As part of this project we only implemented 14 out of 16 identified coupling criteria. The following two criteria are solely described as part of the decomposition model in Chapter \ref{cha:decomposition}.

\begin{itemize}
\item \textit{Mutability} defined whether a nanoentity is mutable or immutable.
\item \textit{Network Traffic Suitability} illustrates the implications when this nanoentity is exposed to a remote interface.
\end{itemize}

Both criteria influence the cost of a service cut. Services owning immutable data with little network traffic can easily be extracted into a separated service. Mutable data causing lots of traffic however should preferrably not be extracted. The scoring concept could be enhanced to also be capable of supporting communication requirements.

\section{Algorithms \& Approach}

This section illustrates a series of possible improvements to the algorithms.

\subsection{Additional Leung Layer}

The non-deterministic nature of the Leung algorithm causes the calculation result to be unstable. This has advantages and disadvantes as oulined in Section \ref{subsec:algoDiscussion}. As an architect I would expect the Service Cutter to assist me with non-deterministic algorithms in a way that the possible service cuts are automatically calcaluted, compared and rated. This additional layer would allow me to easily select the best candidate service cut.

\subsection{MCL adapter}
\label{subsec:mclAdapter}

As outlined in Section \ref{sec:algorithms} the MCL algorithm could be used in the Service Cutter as well.

The reference implementation of the MCL algorithm is provided as a \gls{c} based command line tool. With some effort this algorithm could be integrated into the Service Cutter using \gls{JNI} or an integration based on text files.

An assessment of the MCL algorithm may produce better results compared to the other algorithms.

\subsection{Alternative Algorithms and Optimizations of Existing Algorithms}

Our evaluation of suitable graph clustering algorithms was limited to the ones having a stable Java implementation. Further research may prove that other algorithms are capable of calculating even better candidate service cuts based on our input data.

Furthermore existing algorithms may be improved with optimizations. For instance Lancichinetti and Fortunato\cite{lancichinetti2009community} valuated a set of improved versions of the Girvan-Newman algorithm as well as a collection of alternative algorithms.

We assume that several optimizations in the area of the underlying algorithm can be achieved when the selection is not limited to existing Java implementations.

\section{Tooling}

A set of enhancements of the Service Cutter as a tool may enhance its value to the users.

\subsubsection{Traceability of User Representations}

It is important that the calculated data is presented to the user in a way for him to understand why the candidate service cuts have been selected. By visualizing user representations like use cases, the user gets a better understanding of how his input and definitions affect the suggested architecture. 

Along with the user representations, the scores could be visualized per coupling criterion so that the user understands the impact of priority changes and input enhancements.

\subsubsection{Adjust Suggested Solutions}

The architect is able to adjust the solution by moving a nanoentity from one to another service. He instantly sees the impact of his adjustment as the rating of each coupling criterion is visualized.

\subsection{Configurations for Advanced Users}

For a normal usage, the Service Cutter provides reasonable defaults which have been tested with example projects. Advanced users might want to change or enhance existing coupling criteria or characteristics.

Furthermore the Service Cutter could guide the architect through a questionnaire in order to apply different presets of characterization defaults or priorities.

\subsection{Iterative Enhancements}

Projects are often implemented in subsequent stages. The selected service cut of the first iteration influences the design decision of the second iteration. The Service Cutter therefore should allow the user to load a previously persisted service cut into the new model.

\section{Toolchain Integration}

Providing interfaces to existing tools lowers the cost of using the Service Cutter considerably. We therefore recommend to develop integrations with popular software development tools.

\subsection{Adapters for the Input Format}

Writing the required import format is a significant effort. The model containing the nanoentities and their relations could automatically be parsed from an \gls{ORM} configuration or an existing database schema.

The use cases could be parsed from existing machine-readable \gls{UML} diagrams (e.g. from Enterprise Architect\cite{entArch}) or \gls{API} documentation 

\subsection{Use Solution as a Basis for Working Software}

If the solution is good enough to be used as an initial architecture of a system, it can be used to build the suggested services. As the Service Cutter has sophisticated information about the usage of nanoentities in use cases, it is able to generate the APIs used to communicate between services. 

Depending on the communication layer used to communicate between services these APIs look differently. In a messaging based system the Service Cutter could generate a set of messages or events needed to communicate between services. When services interact by RESTful HTTP interfaces, the Service Cutter is able to generate Swagger\cite{swagger} API definitions for the resources which need to be part of the published language\cite[p.375]{evans2003domain} of the system. 

\section{Conceptual Refinements}

Besides the technical enhancements, we also collected a set of conceptual improvements.

\subsection{Logical and Physical Services}

As outlined in Section \ref{sec:serviceIntro} there are two different definitions for the term service. A technical service may contain a number of logical services. This mitigates the cost associated with remoting when two related nanoservices are split into two different services. The Service Cutter could reflect those differences in the scoring logic.

\subsection{Caching}

Caching is data redundancy that is used to reduce the cost of coupling between services. It affects an architect's decision when to extract nanoentities into separate services and therefore it could be added to the Service Cutter.

\subsection{Document Architectural Decisions}

\begin{quote}
	Architectural decisions capture key design issues and the rationale behind chosen solutions.\cite{zioAD}
\end{quote}

Documenting architectural decisions is a significant documentation artifact of every long-term software project. In order to retrace architectural decisions taken with help of the Service Cutter, important solutions enhanced with discussion notes could be saved persistently. These notes could be captures as free text, Y-Templates\cite{zimmermann2012yTemplate} or other architectural decision templates\footnote{Zimmermann \textit{et al} compiled a comparison of seven publicly available decision templates\cite[p. 3]{zimmermann2015architectural}}.

\subsection{Relationships between Coupling Criteria}

A relationship between coupling criteria like the following might have significant impact on service decomposition:

\textit{Nanoentities with huge storage requirements should not be placed in the same service as nanoentities with high consistency requirements.}

Such a relationship should be incorporated in the Service Cutter's decomposition algorithm. Another way of integration would be to present a warning to the user whenever a critical combination of characteristics appears in a suggested service cut.

\section{Suggested Service Cut Grading}
\label{sec:suggested-cut-grades}

We suggested a questionnaire to assess candidate service cuts in Section \ref{sec:decompositionRequirements}. This distinction could automatically be performed by the Service Cutter and visualized using a indicator similar to a traffic light.

\section{Handling of Large Data Volumes}

Our two test systems are relatively small compared to a typical enterprise system. Therefore the required information to analyze such a system is very large. The data model is probably already existing in a machine-readable format -- the use cases however might not exist and a systematic characterization of the nanoentities are likely not available. It is therefore an important question how such a system could be analyzed using the Service Cutter.

The following questions need to be investigated:

\begin{enumerate}
\item Can an existing data model automatically be transformed into the Service Cutter's import format?
\item Can the Service Cutter calculate meaningful candidate service cuts without taking use cases into account?
\item Can the Service Cutter offer a \gls{UI} that simplifies characterizations of a large data models?
\end{enumerate}

One approach we suggest is to allow a user to specify the coupling on the level of an entity instead of a nanoentity. Other ideas would have to be gathered and evaluated in subsequent projects.

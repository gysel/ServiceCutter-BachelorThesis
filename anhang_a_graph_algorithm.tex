\chapter{Clustering Graph Evaluation}
\label{appendix:graphClustering}

To implement the graph approach described in Section \ref{subsec:approach1_graph}, a clustering algorithm is required to split the undirected, weighted graph into groups of nodes having as few connections between the groups as possible. 

\section{Requirements}

The requirements listed in Table \ref{tab:requirementsAlgorithm} should be met by the algorithm and its implementation:

\begin{table}[H]
	\centering
	\caption{Algorithm Requirements}
	\label{tab:requirementsAlgorithm}
	\begin{tabular}{|p{100pt}|p{250pt}|p{50pt}|}
		\hline	
		Name & Description & Priority \\
		\hline
		Distinct Clusters & Every nanoentity is contained once and only once in a cluster. & High  \\
		\hline
		Balanced Coupling & The sum of weights of the edges a cluster connects with other clusters should be similar for all clusters. & High \\ %TODO besser formulieren
		\hline
		Minimal Coupling & The total weight of the edges connecting clusters should be minimal. & High \\
		\hline
		Implementation & A free implementation of the algorithm should be available either in Java or another language easily callable from the \gls{JVM}. & High  \\
		\hline
		Number of Clusters & The number of clusters should be defined by a parameter. & Medium \\
		\hline
		Performance & The algorithm should not take longer than 2 minutes on an average computer to cluster 2000 nodes.& Medium \\
		\hline
		Simplicity & It should be possible to understand the mechanism and parameters of the algorithm within a day assuming the mathematical background of an average \gls{HSR} student. & Low \\
		\hline
		%TODO: specify more
		Edge Cases & Cases in which it is unclear which cut is best should be visualized in form of a hint or multiple solution suggestions. & Low \\
		\hline
		License & ? & ? \\
		\hline
	\end{tabular}
\end{table}

\section{Market Overview}

The algorithms listed in Table \ref{tab:algorithmEvaluation} are the result of an online research on clustering and community algorithms.

\begin{table}[H]
	\centering
	\caption{Algorithm Evaluation}
	\label{tab:algorithmEvaluation}
	\begin{tabular}{|p{60pt}|p{140pt}|p{130pt}|p{70pt}|}
		\hline	
		\textbf{Name} & \textbf{Description} & \textbf{Implementation} & \textbf{Assessment} \\ 
		\hline
		MCL - Markov Cluster Algorithm\cite{markovCluster} & A clustering algorithm working on weighted undirected graphs. MCL is based on Random Walks with Markov Chains. & Implementations of MCL are available in R and in Java as a plugin of the Gephi\cite{gephi} platform. & Positive \\
		\hline
		HCS - Highly Connected Subgraphs\cite{hcs} & A clustering algorithm working on unweighted undirected graphs. The CLICK clustering algorithm enhances HCS for weighted edges. & Implementations only available in R. & No Java implementation  \\
		\hline
		Girvan–\newline Newman\cite{girvan} & A clustering algorithm working on weighted undirected graphs based on Edge-Betweenness \footnote{The amount of shortest paths between nodes going through a specific edge.}. & Java implementations exist as part of the Jung\cite{jung} framework (only unweighted graphs) and as a plugin of the Gephi\cite{gephi} platform. & Positive \\
		\hline	
		K-means\cite{kmeans} & A clustering algorithm working with vectors in an n-dimensional space. & Multiple implementations, for example as part of the Spark\cite{spark} framework, are available. & No simple way to transform the problem from a graph to vector based representation found. \\
		\hline
		Apiacoa\cite{apiacoa} & A clustering algorithm working on unweighted undirected graphs. This algorithm is based on maximal modularity clustering. & Apiacoa.org provides an implementation of the algorithm in Java. & No support for weighted edges\\
		\hline
		Epidemic Label Propagation & A clustering algorithm working on weighted (un-)directed graphs. This algorithm was suggested by Raghavan\cite{raghavan} and refined by Leung\cite{leung}. & GraphStream\cite{leungGraphstream} provides an implementation of the algorithm in Java as part of their \texttt{gs-algo} package. & Positive \\
		\hline
		%TODO: what is maximal modularity clusterni?
	\end{tabular}
\end{table}

The remaining three algorithms are Girvan-Newman, MCL, and Leung. Leung is provided by the GraphStream project. Girvan-Newman and MCL are implemented as Gephi plugins. Gephi is a desktop platform with a well developed \gls{UI} to explore and visualize complex graphs and network systems. The platform provides a toolkit to use its functionality without \gls{UI}.  The algorithms code can be extracted from the plugins as \gls{JAR} using the UnpackNBM tool\cite{unpackNBM}.


\section{Detailed Algorithm Evaluation}
\label{appendix:graphClusteringAlgs}

Table \ref{tab:clusterAlgorithms} documents the detailed evaluation of the three candidate algorithms. The \gls{MCL} algorithm is theoretically suitable to calculate the clusters. However we found the Java implementation not to be mature enough as the output contains overlapping or missing nodes so that the \textit{distinct clusters} requirement is not met. Leung and Girvan-Newman are used in the Service Cutter and both provide good results.

\begin{table}[H]
\centering
\caption{Evaluation of cluster algorithms}
\label{tab:clusterAlgorithms}
\begin{tabular}{|p{2cm}|p{4cm}|p{4cm}|p{4cm}|}
\hline
                    & \textbf{MCL}               & \textbf{Leung}                    & \textbf{Girvan-Newman}  \\ \hline
Author              & Stijn van Dongen\cite{markovCluster} & U. N. Raghavan\cite{raghavan}, Ian X.Y. Leung\cite{leung}    & M. E. J. Newman, M. Girvan\cite{girvan} \\ \hline
Year                & 2000                       & 2007/2009                         & \multicolumn{1}{l|}{2003}                       \\ \hline
Name                & Markov Cluster Algorithm   & Epidemic Label Propagation        & \multicolumn{1}{l|}{Girvan–Newman}              \\ \hline
Approach            & Random walks               & Labels spread to their neighbours & Edge betweenness, based on shortest-paths       \\ \hline
Performance \newline \textit{N: Nodes} \newline \textit{E: Edges}         & $O (N k^2)$ \newline \textit{k: pruning constant} \cite[p.126]{markovCluster} & $O( E N )$ \cite[p.3]{leung}                         & $O ( N^3 )$\cite[p.14]{girvan}       \\ \hline
Java Implementation & Plugin of Gephi\cite{gephiMarkov} & GraphStream project\cite{leungGraphstream} & Plugin of Gephi\cite{gephiMarkov} \\ \hline
Test result         & Bugs                       & Good                              & \multicolumn{1}{l|}{Good}                       \\ \hline
Advantages & - & Does not require the number of clusters as a parameter & Provides stable results \\
 \hline
\end{tabular}
\end{table}

\section{Monster clusters formed by the Leung algorithm}
\label{sec:monsterclusters}

The \enquote{Epidemic Label Propagation} algorithm by Raghavan \textit{et al} occasionally forms so called \enquote{monster} families as described by Leung \textit{et al} resulting in a drop of cohesion in a cluster. 

\enquote{[\dots] certain communities do not form strong enough links to
prevent a foreign \enquote{epidemic} to sweep through.}\cite[p. 5]{leung}

Leung introduced the \enquote{hop attenuation factor} $\delta$ to the algorithm. This parameters decelerates the propagation of a cluster from its origin and therefore encourages a stronger local cluster to form before a large cluster starts to dominate.

We observed monster clusters especially in the DDD sample and were able to reduce their likelyhood by increasing the hop attenuation factor to a value of $\delta \approx 0.55$ compared to a default of $ \delta = 0.1$ as provided by the GraphStream implementation. We decided to keep the value of $\delta = 0.55$ as the default of the Service Cutter.
